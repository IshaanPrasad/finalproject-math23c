nativeincome = mean(mostlynative)
pacificincome = mean(mostlypacific)
whiteincome; blackincome;hispanicincome;asianincome;nativeincome;pacificincome
barplot(c(whiteincome, blackincome, hispanicincome, asianincome, nativeincome, pacificincome), names.arg = c("white", "black", "hispanic", "asian", "native", "pacific"),main = "Income")
#Poverty
mostlywhite = clean$Poverty[white]
mostlyblack = clean$Poverty[black]
mostlyhispanic = clean$Poverty[hispanic]
mostlyasian = clean$Poverty[asian]
mostlynative = clean$Poverty[native]
mostlypacific = clean$Poverty[pacific]
whitepoverty = mean(mostlywhite)
blackpoverty = mean(mostlyblack)
hispanicpoverty = mean(mostlyhispanic)
asianpoverty = mean(mostlyasian)
nativepoverty = mean(mostlynative)
pacificpoverty = mean(mostlypacific)
whitepoverty; blackpoverty;hispanicpoverty;asianpoverty;nativepoverty;pacificpoverty
barplot(c(whitepoverty,blackpoverty,hispanicpoverty,asianpoverty,nativepoverty,pacificpoverty), names.arg = c("white", "black", "hispanic", "asian", "native", "pacific"),main = "Poverty")
income = clean$Income
hispanic = which(clean$Hispanic>50);  length(hispanic)
white = which(clean$White>50); length(white)
black = which(clean$Black>50);  length(black)
native = which(clean$Native>50); length(native)
asian = which(clean$Asian>50); length(asian)
pacific = which(clean$Pacific>50); length(pacific)
mostlywhite = clean$Income[white]
mostlyblack = clean$Income[black]
mostlyhispanic = clean$Income[hispanic]
mostlyasian = clean$Income[asian]
mostlynative = clean$Income[native]
mostlypacific = clean$Income[pacific]
whiteincome = mean(mostlywhite)
blackincome = mean(mostlyblack)
hispanicincome = mean(mostlyhispanic)
asianincome = mean(mostlyasian)
nativeincome = mean(mostlynative)
pacificincome = mean(mostlypacific)
whiteincome; blackincome;hispanicincome;asianincome;nativeincome;pacificincome
barplot(c(whiteincome, blackincome, hispanicincome, asianincome, nativeincome, pacificincome), names.arg = c("white", "black", "hispanic", "asian", "native", "pacific"),main = "Income")
pacific = which(clean$Pacific>50); length(pacific)
mostlywhite = clean$Poverty[white]
mostlyblack = clean$Poverty[black]
mostlyhispanic = clean$Poverty[hispanic]
mostlyasian = clean$Poverty[asian]
mostlynative = clean$Poverty[native]
mostlypacific = clean$Poverty[pacific]
whitepoverty = mean(mostlywhite)
blackpoverty = mean(mostlyblack)
hispanicpoverty = mean(mostlyhispanic)
asianpoverty = mean(mostlyasian)
nativepoverty = mean(mostlynative)
pacificpoverty = mean(mostlypacific)
whitepoverty; blackpoverty;hispanicpoverty;asianpoverty;nativepoverty;pacificpoverty
barplot(c(whitepoverty,blackpoverty,hispanicpoverty,asianpoverty,nativepoverty,pacificpoverty), names.arg = c("white", "black", "hispanic", "asian", "native", "pacific"),main = "Poverty")
mean(pacific)
mean(clean$Pacific)
mean(income)
median(income)
hist(income)
hist(clean$Drive)
hist(clean$Professional)
#Topic 4: Logistic regression
#Convert the WonLost column to a Bernoulli random variable
wealthy <- (as.numeric(income>=100000)); head(wealthy)
professional <- clean$Professional
plot(professional,wealthy)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
wealthy <- (as.numeric(income>=120000)); head(wealthy)
professional <- clean$Professional
plot(professional,wealthy)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
wealthy <- (as.numeric(income>=50000)); head(wealthy)
professional <- clean$Professional
plot(professional,wealthy)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
wealthy <- (as.numeric(income>=150000)); head(wealthy)
professional <- clean$Professional
plot(professional,wealthy)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
wealthy <- (as.numeric(income>=120000)); head(wealthy)
professional <- clean$Professional
plot(professional,wealthy)  #not a great candidate for a straight-line approximation, but let's try
b <- cov(professional,wealthy)/var(professional)    #easy way to get the slope
#Here is the formula for the intercept
a <- mean(wins) - b*mean(runs);a
#We can add this regression line to the plot of the data
abline(a, b, col = "red")
#Here is the formula for the intercept
a <- mean(wealthy) - b*mean(professional);a
#We can add this regression line to the plot of the data
abline(a, b, col = "red")
MLL<- function(alpha, beta) {
-sum( log( exp(alpha+beta*professional)/(1+exp(alpha+beta*professional)) )*wealthy
+ log(1/(1+exp(alpha+beta*professional)))*(1-wealthy) )
}
results<-mle(MLL, start = list(alpha = 0, beta = 0)) #an initial guess is required
if (!require(stats4)) install.packages("stats4"); library(stats4)
results<-mle(MLL, start = list(alpha = 0, beta = 0)) #an initial guess is required
results@coef
curve( exp(results@coef[1]+results@coef[2]*x)/ (1+exp(results@coef[1]+results@coef[2]*x)),col = "blue", add=TRUE)
max(professional)
abline(h=0.5)
plot(professional,wealthy)  #not a great candidate for a straight-line approximation, but let's try
MLL<- function(alpha, beta) {
-sum( log( exp(alpha+beta*professional)/(1+exp(alpha+beta*professional)) )*wealthy
+ log(1/(1+exp(alpha+beta*professional)))*(1-wealthy) )
}
results<-mle(MLL, start = list(alpha = 0, beta = 0)) #an initial guess is required
results@coef
curve( exp(results@coef[1]+results@coef[2]*x)/ (1+exp(results@coef[1]+results@coef[2]*x)),col = "blue", add=TRUE)
abline(h=0.5)
abline(v=c(60,80))
index <- which(professional == 60); head(index)   #games with 3 runs
mean(wealthy[index])   #won 34%
index <- which(runs == 80)    #games with 4 runs
index <- which(professional == 80)    #games with 4 runs
mean(wealthy[index])   #won 63%
index <- which(professional >= 59 & professional <= 61); head(index)   #games with 3 runs
mean(wealthy[index])   #won 34%
index <- which(professional >= 79 & professional <= 81)    #games with 4 runs
mean(wealthy[index])   #won 63%
index <- which(professional >= 58 & professional <= 62); head(index)   #games with 3 runs
mean(wealthy[index])   #won 34%
index <- which(professional >= 78 & professional <= 82)    #games with 4 runs
mean(wealthy[index])   #won 63%
index <- which(professional >= 79.5 & professional <= 80.5)    #games with 4 runs
mean(wealthy[index])   #won 63%
index <- which(professional >= 79 & professional <= 81); head(index)    #games with 4 runs
mean(wealthy[index])   #won 63%
#Topic 4: Logistic regression
wealthy <- (as.numeric(income>=125000)); head(wealthy)
professional <- clean$Professional
plot(professional,wealthy, pch = ".")  #not a great candidate for a straight-line approximation, but let's try
index <- which(professional >= 79 & professional <= 81); head(index)    #games with 4 runs
mean(income[index])   #won 63%
#Topic 4: Logistic regression
wealthy <- (as.numeric(income>=125000)); head(wealthy)
professional <- clean$Professional
plot(professional,wealthy)  #not a great candidate for a straight-line approximation, but let's try
MLL<- function(alpha, beta) {
-sum( log( exp(alpha+beta*professional)/(1+exp(alpha+beta*professional)) )*wealthy
+ log(1/(1+exp(alpha+beta*professional)))*(1-wealthy) )
}
results<-mle(MLL, start = list(alpha = 0, beta = 0)) #an initial guess is required
results@coef
curve( exp(results@coef[1]+results@coef[2]*x)/ (1+exp(results@coef[1]+results@coef[2]*x)),col = "blue", add=TRUE)
abline(h=0.5)
abline(v=c(60,80))
index <- which(professional >= 58 & professional <= 62); head(index)   #games with 3 runs
mean(wealthy[index])   #won 34%
index <- which(professional >= 79 & professional <= 81); head(index)    #games with 4 runs
mean(wealthy[index])   #won 63%
index <- which(professional >= 89 & professional <= 91); head(index)    #games with 4 runs
mean(wealthy[index])   #won 63%
length(index)
index <- which(professional >= 88 & professional <= 92); head(index)    #games with 4 runs
length(index)
mean(wealthy[index])   #won 63%
length(professional)
hsit(professional)
hist(professional)
#Topic 4: Logistic regression
wealthy <- (as.numeric(income>=125000)); head(wealthy)
office <- clean$Office
plot(office,wealthy)  #not a great candidate for a straight-line approximation, but let's try
service <- clean$Service
plot(service,wealthy)  #not a great candidate for a straight-line approximation, but let's try
hist(drive)
hist(clean$Drive)
hist(clean$Transit)
hist(clean$Carpool)
hist(clean$MeanCommute)
commute <- clean$MeanCommute
plot(commute,wealthy)  #not a great candidate for a straight-line approximation, but let's try
hist(clean$PrivateWork)
hist(clean$PublicWork)
private <- clean$PrivateWork
plot(private,wealthy)  #not a great candidate for a straight-line approximation, but let's try
MLL<- function(alpha, beta) {
-sum( log( exp(alpha+beta*private)/(1+exp(alpha+beta*private)) )*wealthy
+ log(1/(1+exp(alpha+beta*private)))*(1-wealthy) )
}
results<-mle(MLL, start = list(alpha = 0, beta = 0)) #an initial guess is required
results@coef
curve( exp(results@coef[1]+results@coef[2]*x)/ (1+exp(results@coef[1]+results@coef[2]*x)),col = "blue", add=TRUE)
hist(clean$Construction)
private <- clean$Construction
plot(private,wealthy)  #not a great candidate for a straight-line approximation, but let's try
private <- clean$Production
plot(private,wealthy)  #not a great candidate for a straight-line approximation, but let's try
constr.prod <- clean$Construction + clean$Production
plot(private,wealthy)  #not a great candidate for a straight-line approximation, but let's try
plot(constr.prod,wealthy)  #not a great candidate for a straight-line approximation, but let's try
MLL<- function(alpha, beta) {
-sum( log( exp(alpha+beta*constr.prod)/(1+exp(alpha+beta*constr.prod)) )*wealthy
+ log(1/(1+exp(alpha+beta*constr.prod)))*(1-wealthy) )
}
results<-mle(MLL, start = list(alpha = 0, beta = 0)) #an initial guess is required
results@coef
curve( exp(results@coef[1]+results@coef[2]*x)/ (1+exp(results@coef[1]+results@coef[2]*x)),col = "blue", add=TRUE)
#Topic 4: Logistic regression
poor <- (as.numeric(income<=50000)); head(poor)
constr.prod <- clean$Construction + clean$Production
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
poor <- (as.numeric(income<=40000)); head(poor)
constr.prod <- clean$Construction + clean$Production
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
poor <- (as.numeric(income<=100000)); head(poor)
constr.prod <- clean$Construction + clean$Production
#Topic 4: Logistic regression
poor <- (as.numeric(income<=100000)); head(poor)
constr.prod <- clean$Construction + clean$Production
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
MLL<- function(alpha, beta) {
-sum( log( exp(alpha+beta*constr.prod)/(1+exp(alpha+beta*constr.prod)) )*poor
+ log(1/(1+exp(alpha+beta*constr.prod)))*(1-poor) )
}
results<-mle(MLL, start = list(alpha = 0, beta = 0)) #an initial guess is required
results@coef
curve( exp(results@coef[1]+results@coef[2]*x)/ (1+exp(results@coef[1]+results@coef[2]*x)),col = "blue", add=TRUE)
constr.prod <- clean$Construction
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
poor <- (as.numeric(income<=50000)); head(poor)
constr.prod <- clean$Construction
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
MLL<- function(alpha, beta) {
-sum( log( exp(alpha+beta*constr.prod)/(1+exp(alpha+beta*constr.prod)) )*poor
+ log(1/(1+exp(alpha+beta*constr.prod)))*(1-poor) )
}
results<-mle(MLL, start = list(alpha = 0, beta = 0)) #an initial guess is required
results@coef
curve( exp(results@coef[1]+results@coef[2]*x)/ (1+exp(results@coef[1]+results@coef[2]*x)),col = "blue", add=TRUE)
constr.prod <- clean$Unemployment
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
constr.prod <- clean$Unemployment
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
max(clean$Unemployment)
MLL<- function(alpha, beta) {
-sum( log( exp(alpha+beta*constr.prod)/(1+exp(alpha+beta*constr.prod)) )*poor
+ log(1/(1+exp(alpha+beta*constr.prod)))*(1-poor) )
}
results<-mle(MLL, start = list(alpha = 0, beta = 0)) #an initial guess is required
results@coef
curve( exp(results@coef[1]+results@coef[2]*x)/ (1+exp(results@coef[1]+results@coef[2]*x)),col = "blue", add=TRUE)
abline(h=0.5)
constr.prod <- clean$Professional + clean$Service + clean$Office
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
poor <- (as.numeric(income<=100000)); head(poor)
constr.prod <- clean$Professional + clean$Service + clean$Office
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
poor <- (as.numeric(income<=750000)); head(poor)
constr.prod <- clean$Professional + clean$Service + clean$Office
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
poor <- (as.numeric(income<=75000)); head(poor)
constr.prod <- clean$Professional + clean$Service + clean$Office
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
constr.prod <- clean$ChildPoverty
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
#Topic 4: Logistic regression
poor <- (as.numeric(income<=50000)); head(poor)
constr.prod <- clean$ChildPoverty
plot(constr.prod,poor)  #not a great candidate for a straight-line approximation, but let's try
### 95% Confidence Interval ###
unemployment = clean$Unemployment
### 95% Confidence Interval ###
hist(unemployment)
### 95% Confidence Interval ###
hist(commute)
f = function(x) dnorm(x,mean(commute), sd(commute))
curve(f)
curve(f, add=T)
### 95% Confidence Interval ###
hist(commute)
f = function(x) dnorm(x,mean(commute), sd(commute))
curve(f, add=T)
### 95% Confidence Interval ###
hist(commute, probability = T)
f = function(x) dnorm(x,mean(commute), sd(commute))
curve(f, add=T)
curve(f, add=T, col = "blue")
commute = clean$Commute
### 95% Confidence Interval ###
N = length(commute)
µ = mean(commute); µ
mu = mean(commute); mu
### 95% Confidence Interval ###
commute = clean$Commute
### 95% Confidence Interval ###
commute = clean$Commute; head(commute)
### 95% Confidence Interval ###
commute = clean$MeanCommute
µ = mean(commute); µ
sigma = sd(commute); sigma
f = function(x) dnorm(x,µ, sigma)
curve(f, add=T, col = "blue")
N = length(commute)
?sample
mean(commute[sample])
sample = sample(n,N); sample
N = length(commute)
n = 1000
sample = sample(n,N); sample
sample = sample(N,n); sample
mean(commute[sample])
xbar = mean(commute[sample])
s = sd(commute[sample])
lower = xbar - 1.96*s/sqrt(1000); lower
upper = xbar + 1.96*s/sqrt(1000); upper
s = sd(commute[sample]);s
N <- 1000
counter <- 0
plot(x =c(mu-4, mu+4), y = c(1,100), type = "n", xlab = "", ylab = "") #blank plot
#Based on Chihara and Hesterberg, section 7.1
#We sample from a normal distribution with known variance but unknown mean mu
#The challenge: given the mean of one sample, to get values of two random variables
#U has a 97.5% probability of being greater than mu
#L has a 97.5% probability of being less than mu
#We are drawing a sample of n=50 from the normal distribution N(mu, sigma).
#The sample mean has a normal distribution with mean mu, variance sigma^2/n.
#If we know that sigma = 4, we can calculate a value
#with the property that a sample mean
#has a 95% chance of lying in the interval [mu-x.add, mu+x.add]
mu <- 23; sigma <- 4; #parameters for the normal distribution
n <- 50  #sample size
x.add <- qnorm(0.975)*(sigma/sqrt(n)); x.add   #what to add or subtract to get U or L
curve(dnorm(x,0,sigma/sqrt(n)), from = -2, to = 2)
abline(v = c(-x.add,x.add), col = "red")
N <- 1000
counter <- 0
plot(x =c(mu-4, mu+4), y = c(1,100), type = "n", xlab = "", ylab = "") #blank plot
for (i in 1:N) {
x <- rnorm(n, mu, sigma) #random sample
U <- mean(x) + x.add #usually greater than the true mean
if (mu < U) counter <- counter + 1 #count +1 if we were correct
if(i <= 100) points(U, i, pch= 23)
}
abline (v = mu, col = "red") #vertical line at true mean
counter/N #what fraction of the time did our statistic U exceed the true mean?
counter <- 0
plot(x =c(mu-4,mu+4), y = c(1,100), type = "n", xlab = "", ylab = "") #blank plot
for (i in 1:N) {
x <- rnorm(n, mu, sigma) #random sample
L <- mean(x) - x.add #usually less than the true mean
if (L < mu) counter <- counter + 1 #count +1 if we were correct
if(i <= 100) points(L, i, pch= 22)
}
abline (v = mu, col = "red") #vertical line at true mean
counter/N #what fraction of the time was our statistic L less than the true mean?
counter <- 0
plot(x =c(mu-4,mu+4), y = c(1,100), type = "n", xlab = "", ylab = "") #blank plot
for (i in 1:N) {
x <-rnorm(n, mu, sigma) #random sample
L <- mean(x) - x.add #usually less than the true mean
U <- mean(x) + x.add #usually greater than the true mean
if (L < mu && mu < U) counter <- counter + 1 #count +1 if we were correct
if(i <= 100) {
points(L, i, pch= 22)
points(U, i, pch= 23)
segments(L, i, U, i)
}
}
abline (v = mu, col = "red") #vertical line at true mean
counter/N #what fraction of the time did our confidence interval include the true mean?
counter <- 0
### 95% Confidence Interval ###
commute = clean$MeanCommute
µ = mean(commute); µ
sigma = sd(commute); sigma
hist(commute, probability = T)
f = function(x) dnorm(x,µ, sigma)
curve(f, add=T, col = "blue")
N = length(commute)
n = 10000
counter <- 0
plot(x =c(mu-4,mu+4), y = c(1,10000), type = "n", xlab = "", ylab = "") #blank plot
plot(x =c(µ-4,µ+4), y = c(1,10000), type = "n", xlab = "", ylab = "") #blank plot
for (i in 1:n) {
x <-rnorm(n, mu, sigma) #random sample
sample = sample(N,1000)
xbar = mean(commute[sample])
s = sd(commute[sample]);s
lower = xbar - 1.96*s/sqrt(1000); lower
upper = xbar + 1.96*s/sqrt(1000); upper
if (lower < µ && µ < upper) counter <- counter + 1
if(i <= 10000) {
points(lower, i, pch= 22)
points(upper, i, pch= 23)
segments(lower, i, upper, i)
}
}
abline (v = µ, col = "red") #vertical line at true mean
counter/n
counter <- 0
plot(x =c(µ-2,µ+2), y = c(1,10000), type = "n", xlab = "", ylab = "") #blank plot
for (i in 1:1000) {
x <-rnorm(n, mu, sigma) #random sample
sample = sample(N,n)
xbar = mean(commute[sample])
s = sd(commute[sample]);s
lower = xbar - 1.96*s/sqrt(n); lower
upper = xbar + 1.96*s/sqrt(n); upper
if (lower < µ && µ < upper) counter <- counter + 1
if(i <= 1000) {
points(lower, i, pch= 22)
points(upper, i, pch= 23)
segments(lower, i, upper, i)
}
}
counter <- 0
plot(x =c(µ-2,µ+2), y = c(1,1000), type = "n", xlab = "", ylab = "") #blank plot
for (i in 1:1000) {
x <-rnorm(n, mu, sigma) #random sample
sample = sample(N,n)
xbar = mean(commute[sample])
s = sd(commute[sample]);s
lower = xbar - 1.96*s/sqrt(n); lower
upper = xbar + 1.96*s/sqrt(n); upper
if (lower < µ && µ < upper) counter <- counter + 1
if(i <= 1000) {
points(lower, i, pch= 22)
points(upper, i, pch= 23)
segments(lower, i, upper, i)
}
}
abline (v = µ, col = "red") #vertical line at true mean
counter/n
N = length(commute)
n = 1000
sample = sample(N,n)
xbar = mean(commute[sample])
s = sd(commute[sample]);s
lower = xbar - 1.96*s/sqrt(n); lower
upper = xbar + 1.96*s/sqrt(n); upper
µ = mean(commute); µ
counter <- 0
plot(x =c(µ-2,µ+2), y = c(1,1000), type = "n", xlab = "", ylab = "") #blank plot
for (i in 1:1000) {
sample = sample(N,n)
xbar = mean(commute[sample])
s = sd(commute[sample])
lower = xbar - 1.96*s/sqrt(n)
upper = xbar + 1.96*s/sqrt(n)
if (lower < µ && µ < upper) counter <- counter + 1
if(i <= 1000) {
points(lower, i, pch= 22)
points(upper, i, pch= 23)
segments(lower, i, upper, i)
}
}
abline (v = µ, col = "red") #vertical line at true mean
counter/n
n = 5000
plot(x =c(µ-2,µ+2), y = c(1,1000), type = "n", xlab = "", ylab = "") #blank plot
counter <- 0
for (i in 1:1000) {
sample = sample(N,n)
xbar = mean(commute[sample])
s = sd(commute[sample])
lower = xbar - 1.96*s/sqrt(n)
upper = xbar + 1.96*s/sqrt(n)
if (lower < µ && µ < upper) counter <- counter + 1
if(i <= 1000) {
points(lower, i, pch= 22)
points(upper, i, pch= 23)
segments(lower, i, upper, i)
}
}
abline (v = µ, col = "red") #vertical line at true mean
counter/n
counter/1000
counter <- 0
plot(x =c(µ-2,µ+2), y = c(1,100), type = "n", xlab = "", ylab = "") #blank plot
for (i in 1:100) {
sample = sample(N,n)
xbar = mean(commute[sample])
s = sd(commute[sample])
lower = xbar - 1.96*s/sqrt(n)
upper = xbar + 1.96*s/sqrt(n)
if (lower < µ && µ < upper) counter <- counter + 1
if(i <= 100) {
points(lower, i, pch= 22)
points(upper, i, pch= 23)
segments(lower, i, upper, i)
}
}
abline (v = µ, col = "red") #vertical line at true mean
counter/100
counter <- 0
plot(x =c(µ-2,µ+2), y = c(1,100), type = "n", xlab = "", ylab = "") #blank plot
for (i in 1:100) {
sample = sample(N,n)
xbar = mean(commute[sample])
s = sd(commute[sample])
lower = xbar - 1.96*s/sqrt(n)
upper = xbar + 1.96*s/sqrt(n)
if (lower < µ && µ < upper) counter <- counter + 1
if(i <= 100) {
points(lower, i, pch= 22)
points(upper, i, pch= 23)
segments(lower, i, upper, i)
}
}
abline (v = µ, col = "red") #vertical line at true mean
counter/100
hist(commute, probability = T)
